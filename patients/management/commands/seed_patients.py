from django.core.management.base import BaseCommand
from django.db import transaction, connection
from patients.models import Patient
from tenants.models import Tenant
import random
from datetime import date


class Command(BaseCommand):
    help = 'Tworzy przyk≈Çadowych pacjent√≥w z prawid≈Çowymi numerami PESEL dla wybranego tenanta'

    def add_arguments(self, parser):
        parser.add_argument(
            'tenant_schema',
            type=str,
            help='Schema name tenanta (np. "tenant1", "przychodnia_a")'
        )
        parser.add_argument(
            '--count',
            type=int,
            default=20,
            help='Liczba pacjent√≥w do utworzenia (domy≈õlnie: 20)'
        )
        parser.add_argument(
            '--clear',
            action='store_true',
            help='Usu≈Ñ wszystkich istniejƒÖcych pacjent√≥w przed dodaniem nowych'
        )

    def handle(self, *args, **options):
        tenant_schema = options['tenant_schema']
        count = options['count']
        
        # Sprawd≈∫ czy tenant istnieje
        try:
            tenant = Tenant.objects.get(schema_name=tenant_schema)
        except Tenant.DoesNotExist:
            self.stdout.write(
                self.style.ERROR(f'Tenant "{tenant_schema}" nie istnieje!')
            )
            # Poka≈º dostƒôpne tenant√≥w
            available_tenants = Tenant.objects.all()
            if available_tenants:
                self.stdout.write('Dostƒôpne tenant√≥w:')
                for t in available_tenants:
                    self.stdout.write(f'  - {t.schema_name} ({t.name})')
            return
        
        # Prze≈ÇƒÖcz na schemat tenanta
        connection.set_schema_to_tenant(tenant)
        
        self.stdout.write(
            self.style.SUCCESS(f'üè• Pracujƒô z tenant: {tenant.name} (schema: {tenant_schema})')
        )
        
        if options['clear']:
            deleted_count = Patient.objects.count()
            Patient.objects.all().delete()
            self.stdout.write(
                self.style.WARNING(f'Usuniƒôto {deleted_count} istniejƒÖcych pacjent√≥w z {tenant.name}.')
            )

        # Przyk≈Çadowe imiona i nazwiska
        imiona_m = [
            'Adam', 'Andrzej', 'Antoni', 'Bartosz', 'Damian', 'Daniel', 'Dawid',
            'Filip', 'Grzegorz', 'Jakub', 'Jan', 'Kamil', 'Krzysztof', '≈Åukasz',
            'Maciej', 'Marcin', 'Marek', 'Mateusz', 'Micha≈Ç', 'Pawe≈Ç', 'Piotr',
            'Przemys≈Çaw', 'Rafa≈Ç', 'Robert', 'Sebastian', 'Szymon', 'Tomasz', 'Wojciech'
        ]
        
        imiona_k = [
            'Agnieszka', 'Aleksandra', 'Anna', 'Barbara', 'Beata', 'Dorota', 
            'Ewa', 'Gabriela', 'Gra≈ºyna', 'Halina', 'Iwona', 'Joanna', 'Justyna',
            'Katarzyna', 'Krystyna', 'Magdalena', 'Ma≈Çgorzata', 'Maria', 'Monika',
            'Natalia', 'Paulina', 'Renata', 'Sylwia', 'Teresa', 'Urszula', 'Wioletta'
        ]
        
        nazwiska = [
            'Nowak', 'Kowalski', 'Wi≈õniewski', 'DƒÖbrowski', 'Lewandowski', 'W√≥jcik',
            'Kami≈Ñski', 'Kowalczyk', 'Zieli≈Ñski', 'Szyma≈Ñski', 'Wo≈∫niak', 'Koz≈Çowski',
            'Jankowski', 'Wojciechowski', 'Kwiatkowski', 'Kaczmarek', 'Mazur', 'Krawczyk',
            'Piotrowski', 'Grabowski', 'Nowakowski', 'Paw≈Çowski', 'Michalski', 'Nowicki',
            'Adamczyk', 'Dudek', 'ZajƒÖc', 'Wieczorek', 'Jab≈Ço≈Ñski', 'Kr√≥l', 'Majewski',
            'Olszewski', 'Jaworski', 'Wr√≥bel', 'Malinowski', 'Pawlak', 'Witkowski'
        ]

        # Przyk≈Çadowe domeny email
        domeny_email = [
            'gmail.com', 'wp.pl', 'onet.pl', 'o2.pl', 'interia.pl', 
            'gazeta.pl', 'poczta.onet.pl', 'tlen.pl', 'yahoo.com'
        ]

        created_count = 0
        
        with transaction.atomic():
            for i in range(count):
                try:
                    # Losuj p≈Çeƒá
                    plec = random.choice(['M', 'K'])
                    
                    # Losuj imiƒô na podstawie p≈Çci
                    if plec == 'M':
                        imie = random.choice(imiona_m)
                    else:
                        imie = random.choice(imiona_k)
                    
                    nazwisko = random.choice(nazwiska)
                    
                    # Generuj prawid≈Çowy PESEL
                    pesel = self.generate_valid_pesel(plec)
                    if not pesel:
                        continue
                    
                    # Sprawd≈∫ czy PESEL ju≈º istnieje w tym tenant
                    existing_patient = Patient.objects.search_by_pesel(pesel).first()
                    if existing_patient:
                        self.stdout.write(
                            self.style.WARNING(f'PESEL {pesel} ju≈º istnieje, pomijam...')
                        )
                        continue
                    
                    # Generuj email (z ma≈ÇƒÖ szansƒÖ na brak)
                    if random.random() > 0.1:  # 90% ma email
                        email = f"{imie.lower()}.{nazwisko.lower()}@{random.choice(domeny_email)}"
                        # Upewnij siƒô ≈ºe email jest unikalny
                        counter = 1
                        original_email = email
                        while Patient.objects.filter(email=email).exists():
                            email = f"{original_email.split('@')[0]}{counter}@{original_email.split('@')[1]}"
                            counter += 1
                    else:
                        email = None
                    
                    # Generuj telefon (z ma≈ÇƒÖ szansƒÖ na brak)
                    if random.random() > 0.15:  # 85% ma telefon
                        # Polskie numery telefon√≥w
                        prefix = random.choice(['500', '501', '502', '503', '504', '505', '506', '507', '508', '509',
                                              '510', '511', '512', '513', '514', '515', '516', '517', '518', '519',
                                              '530', '531', '532', '533', '534', '535', '536', '537', '538', '539',
                                              '570', '571', '572', '573', '574', '575', '576', '577', '578', '579',
                                              '600', '601', '602', '603', '604', '605', '606', '607', '608', '609'])
                        phone = f"+48{prefix}{random.randint(100000, 999999)}"
                    else:
                        phone = None
                    
                    # Utw√≥rz pacjenta
                    patient = Patient.objects.create(
                        first_name_encrypted=imie,
                        last_name_encrypted=nazwisko,
                        pesel_encrypted=pesel,
                        email=email,
                        phone=phone
                    )
                    
                    created_count += 1
                    
                    # Poka≈º postƒôp co 5 pacjent√≥w
                    if created_count % 5 == 0:
                        self.stdout.write(f'‚úÖ Utworzono {created_count}/{count} pacjent√≥w w {tenant.name}...')
                        
                except Exception as e:
                    self.stdout.write(
                        self.style.ERROR(f'‚ùå B≈ÇƒÖd podczas tworzenia pacjenta {i+1}: {str(e)}')
                    )
                    continue

        self.stdout.write(
            self.style.SUCCESS(f'üéâ Pomy≈õlnie utworzono {created_count} pacjent√≥w w tenant "{tenant.name}"!')
        )
        
        # Poka≈º statystyki
        total_patients = Patient.objects.count()
        self.stdout.write(f'üìä ≈ÅƒÖczna liczba pacjent√≥w w {tenant.name}: {total_patients}')
        
        # Poka≈º przyk≈Çadowe dane
        if created_count > 0:
            self.stdout.write('\n' + '='*60)
            self.stdout.write(f'PRZYK≈ÅADOWI PACJENCI W TENANT "{tenant.name.upper()}":')
            self.stdout.write('='*60)
            
            for patient in Patient.objects.all()[:5]:
                self.stdout.write(
                    f"‚Ä¢ {patient.get_decrypted_full_name()} "
                    f"(PESEL: {patient.get_masked_pesel()}, "
                    f"ur. {patient.date_of_birth}, "
                    f"p≈Çeƒá: {patient.gender})"
                )
        
        # Informacja o dostƒôpie
        self.stdout.write('\n' + '='*60)
        self.stdout.write(f'üåê Aby zobaczyƒá pacjent√≥w w przeglƒÖdarce:')
        self.stdout.write(f'   http://{tenant_schema}.localhost:8000/pacjenci/')
        self.stdout.write('='*60)

        # Przyk≈Çadowe imiona i nazwiska
        imiona_m = [
            'Adam', 'Andrzej', 'Antoni', 'Bartosz', 'Damian', 'Daniel', 'Dawid',
            'Filip', 'Grzegorz', 'Jakub', 'Jan', 'Kamil', 'Krzysztof', '≈Åukasz',
            'Maciej', 'Marcin', 'Marek', 'Mateusz', 'Micha≈Ç', 'Pawe≈Ç', 'Piotr',
            'Przemys≈Çaw', 'Rafa≈Ç', 'Robert', 'Sebastian', 'Szymon', 'Tomasz', 'Wojciech'
        ]
        
        imiona_k = [
            'Agnieszka', 'Aleksandra', 'Anna', 'Barbara', 'Beata', 'Dorota', 
            'Ewa', 'Gabriela', 'Gra≈ºyna', 'Halina', 'Iwona', 'Joanna', 'Justyna',
            'Katarzyna', 'Krystyna', 'Magdalena', 'Ma≈Çgorzata', 'Maria', 'Monika',
            'Natalia', 'Paulina', 'Renata', 'Sylwia', 'Teresa', 'Urszula', 'Wioletta'
        ]
        
        nazwiska = [
            'Nowak', 'Kowalski', 'Wi≈õniewski', 'DƒÖbrowski', 'Lewandowski', 'W√≥jcik',
            'Kami≈Ñski', 'Kowalczyk', 'Zieli≈Ñski', 'Szyma≈Ñski', 'Wo≈∫niak', 'Koz≈Çowski',
            'Jankowski', 'Wojciechowski', 'Kwiatkowski', 'Kaczmarek', 'Mazur', 'Krawczyk',
            'Piotrowski', 'Grabowski', 'Nowakowski', 'Paw≈Çowski', 'Michalski', 'Nowicki',
            'Adamczyk', 'Dudek', 'ZajƒÖc', 'Wieczorek', 'Jab≈Ço≈Ñski', 'Kr√≥l', 'Majewski',
            'Olszewski', 'Jaworski', 'Wr√≥bel', 'Malinowski', 'Pawlak', 'Witkowski'
        ]

        # Przyk≈Çadowe domeny email
        domeny_email = [
            'gmail.com', 'wp.pl', 'onet.pl', 'o2.pl', 'interia.pl', 
            'gazeta.pl', 'poczta.onet.pl', 'tlen.pl', 'yahoo.com'
        ]

        created_count = 0
        
        with transaction.atomic():
            for i in range(count):
                try:
                    # Losuj p≈Çeƒá
                    plec = random.choice(['M', 'K'])
                    
                    # Losuj imiƒô na podstawie p≈Çci
                    if plec == 'M':
                        imie = random.choice(imiona_m)
                    else:
                        imie = random.choice(imiona_k)
                    
                    nazwisko = random.choice(nazwiska)
                    
                    # Generuj prawid≈Çowy PESEL
                    pesel = self.generate_valid_pesel(plec)
                    
                    # Generuj email (z ma≈ÇƒÖ szansƒÖ na brak)
                    if random.random() > 0.1:  # 90% ma email
                        email = f"{imie.lower()}.{nazwisko.lower()}@{random.choice(domeny_email)}"
                        # Upewnij siƒô ≈ºe email jest unikalny
                        counter = 1
                        original_email = email
                        while Patient.objects.filter(email=email).exists():
                            email = f"{original_email.split('@')[0]}{counter}@{original_email.split('@')[1]}"
                            counter += 1
                    else:
                        email = None
                    
                    # Generuj telefon (z ma≈ÇƒÖ szansƒÖ na brak)
                    if random.random() > 0.15:  # 85% ma telefon
                        # Polskie numery telefon√≥w
                        prefix = random.choice(['500', '501', '502', '503', '504', '505', '506', '507', '508', '509',
                                              '510', '511', '512', '513', '514', '515', '516', '517', '518', '519',
                                              '530', '531', '532', '533', '534', '535', '536', '537', '538', '539',
                                              '570', '571', '572', '573', '574', '575', '576', '577', '578', '579',
                                              '600', '601', '602', '603', '604', '605', '606', '607', '608', '609'])
                        phone = f"+48{prefix}{random.randint(100000, 999999)}"
                    else:
                        phone = None
                    
                    # Utw√≥rz pacjenta
                    patient = Patient.objects.create(
                        first_name_encrypted=imie,
                        last_name_encrypted=nazwisko,
                        pesel_encrypted=pesel,
                        email=email,
                        phone=phone
                    )
                    
                    created_count += 1
                    
                    # Poka≈º postƒôp co 5 pacjent√≥w
                    if created_count % 5 == 0:
                        self.stdout.write(f'Utworzono {created_count}/{count} pacjent√≥w...')
                        
                except Exception as e:
                    self.stdout.write(
                        self.style.ERROR(f'B≈ÇƒÖd podczas tworzenia pacjenta {i+1}: {str(e)}')
                    )
                    continue

        self.stdout.write(
            self.style.SUCCESS(f'Pomy≈õlnie utworzono {created_count} pacjent√≥w!')
        )
        
        # Poka≈º przyk≈Çadowe dane
        if created_count > 0:
            self.stdout.write('\n' + '='*50)
            self.stdout.write('PRZYK≈ÅADOWI PACJENCI:')
            self.stdout.write('='*50)
            
            for patient in Patient.objects.all()[:5]:
                self.stdout.write(
                    f"‚Ä¢ {patient.get_decrypted_full_name()} "
                    f"(PESEL: {patient.get_masked_pesel()}, "
                    f"ur. {patient.date_of_birth}, "
                    f"p≈Çeƒá: {patient.gender})"
                )

    def generate_valid_pesel(self, plec='M'):
        """
        Generuje prawid≈Çowy numer PESEL z sumƒÖ kontrolnƒÖ
        plec: 'M' dla mƒô≈ºczyzny, 'K' dla kobiety
        
        Struktura PESEL: RRMMDDSSSP(K)
        RR - rok urodzenia
        MM - miesiƒÖc z kodowaniem stulecia  
        DD - dzie≈Ñ
        SSS - numer porzƒÖdkowy (3 cyfry)
        P - p≈Çeƒá (1 cyfra: parzysta=K, nieparzysta=M)
        K - cyfra kontrolna
        """
        # Losuj datƒô urodzenia (od 1950 do 2005)
        year = random.randint(1950, 2005)
        month = random.randint(1, 12)
        
        # Dni w miesiƒÖcu
        days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        
        # Sprawd≈∫ rok przestƒôpny
        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):
            days_in_month[1] = 29
            
        day = random.randint(1, days_in_month[month - 1])
        
        # Konwertuj na format PESEL
        year_short = year % 100
        
        # Kodowanie miesiƒÖca wed≈Çug stulecia
        if 1900 <= year <= 1999:
            month_coded = month
        elif 2000 <= year <= 2099:
            month_coded = month + 20
        elif 1800 <= year <= 1899:
            month_coded = month + 80
        elif 2100 <= year <= 2199:
            month_coded = month + 40
        else:
            month_coded = month
        
        # Numer porzƒÖdkowy (3 cyfry) - losowy
        serial_number = random.randint(0, 999)
        
        # Cyfra p≈Çci (1 cyfra)
        if plec == 'M':
            # Mƒô≈ºczy≈∫ni - cyfra nieparzysta (1, 3, 5, 7, 9)
            gender_digit = random.choice([1, 3, 5, 7, 9])
        else:
            # Kobiety - cyfra parzysta (0, 2, 4, 6, 8)
            gender_digit = random.choice([0, 2, 4, 6, 8])
        
        # Sk≈Çadaj PESEL (bez cyfry kontrolnej) - 10 cyfr
        pesel_parts = [
            f"{year_short:02d}",        # 2 cyfry
            f"{month_coded:02d}",       # 2 cyfry
            f"{day:02d}",               # 2 cyfry
            f"{serial_number:03d}",     # 3 cyfry
            f"{gender_digit:01d}"       # 1 cyfra
        ]
        
        pesel_without_control = ''.join(pesel_parts)
        
        # Sprawd≈∫ czy mamy 10 cyfr
        if len(pesel_without_control) != 10:
            self.stdout.write(
                self.style.ERROR(f'B≈ÇƒÖd: PESEL bez kontrolnej ma {len(pesel_without_control)} cyfr: {pesel_without_control}')
            )
            return None
        
        # Oblicz cyfrƒô kontrolnƒÖ
        weights = [1, 3, 7, 9, 1, 3, 7, 9, 1, 3]
        checksum = 0
        
        for i, digit in enumerate(pesel_without_control):
            checksum += int(digit) * weights[i]
        
        control_digit = (10 - (checksum % 10)) % 10
        
        # Finalny PESEL - 11 cyfr
        pesel = pesel_without_control + str(control_digit)
        
        # Sprawd≈∫ czy mamy 11 cyfr
        if len(pesel) != 11:
            self.stdout.write(
                self.style.ERROR(f'B≈ÇƒÖd: Finalny PESEL ma {len(pesel)} cyfr: {pesel}')
            )
            return None
        
        return pesel